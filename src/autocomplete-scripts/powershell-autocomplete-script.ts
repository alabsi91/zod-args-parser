import { transformOptionToArgument } from "../parse/parser-utilities.ts";

import type { Cli } from "../types/definitions-types.ts";

/**
 * - Generates a PowerShell autocomplete script for your CLI.
 * - The script assumes that your CLI is available as a `.ps1` file in the environment variable. For example:
 *   `cliName.ps1`.
 * - This should return a path to your script: `(Get-Command <cliName>.ps1).Source`
 * - The generated script should be added to your `profile.ps1` file:
 *
 *   - Run: `notepad $profile`
 *   - Add the following line: `. "<generated script path>"`
 *   - Save and reopen powershell to take effect
 */
export function generatePowerShellAutocompleteScript(cliDefinition: Cli): string {
  const subcommands = cliDefinition.subcommands ?? [];
  const meta = cliDefinition.meta ?? {};

  type MappedCommands = Record<string, { options: string[]; aliases: string[] }>;

  const mappedCommands: MappedCommands = {};

  for (const subcommand of subcommands) {
    mappedCommands[subcommand.name] = {
      options: subcommand.options ? Object.keys(subcommand.options).map(key => transformOptionToArgument(key)) : [],
      aliases: subcommand.aliases ?? [],
    };
  }

  const subcommandsString = Object.keys(mappedCommands)
    .map(key => `'${key}'`)
    .join(", ");

  const optionsNames = cliDefinition.options
    ? Object.keys(cliDefinition.options).map(key => transformOptionToArgument(key))
    : [];
  const cliOptionsString = optionsNames.map(option => `'${option}'`).join(", ");

  let switchCase = "switch ($subcommand) {\n";
  for (const [key, { options, aliases }] of Object.entries(mappedCommands)) {
    const optionsString = options.map(option => `'${option}'`).join(", ");
    switchCase += `        '${key}' { @(${optionsString}) }\n`;
    for (const a of aliases) {
      switchCase += `        '${a}' { @(${optionsString}) }\n`;
    }
  }
  switchCase += `        default { @(${cliOptionsString}) }\n    }`;

  const description = meta.description ?? meta.descriptionMarkdown;

  let functionInfo = "";
  if (description) {
    functionInfo = `<#\n.DESCRIPTION\n${description}\n${meta.example ? `\n.EXAMPLE\n${meta.example}` : ""}\n#>`;
  }

  return `# Auto-generated by zod-args-parser

${functionInfo}
function ${cliDefinition.cliName} {
    param(
        [Parameter(Position = 0, Mandatory = $false)]
        [string]$subcommand,
        [Parameter(Position = 1, ValueFromRemainingArguments = $true)]
        [string[]]$arguments
    )
    $scriptPath = (Get-Command '${cliDefinition.cliName}.ps1').Source
    if ($scriptPath) {
        $argumentList = @($subcommand) + ($arguments | Where-Object { $_ -notin '--', '--%' }) | Where-Object { $_ -ne '' }
        & $scriptPath @argumentList
        return
    }
    Write-Error "Could not find '${cliDefinition.cliName}.ps1' script"
}

Register-ArgumentCompleter -CommandName '${cliDefinition.cliName}' -ParameterName 'subcommand' -ScriptBlock {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
    $subcommands = @(${subcommandsString}${subcommandsString && cliOptionsString ? ", " : ""}${cliOptionsString})
    $subcommands | Where-Object { $_ -like "$wordToComplete*" }
}

Register-ArgumentCompleter -CommandName '${cliDefinition.cliName}' -ParameterName 'arguments' -ScriptBlock {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
    $subcommand = $commandAst.CommandElements[1].Value
    $arguments = ${switchCase}
    $arguments | Where-Object { $_ -like "$wordToComplete*" }
}`;
}
