import { transformOptionToArgument } from "../parse/parser-utilities.ts";

import type { Cli } from "../types/definitions-types.ts";

/**
 * Generates a PowerShell autocomplete script for a CLI.
 *
 * Instructions:
 *
 * - Ensure your CLI is available as a `.ps1` file in your environment. e.g., `cliName.ps1`.
 * - Add the generated script to your `profile.ps1` file:
 *
 *   1. Run: `notepad $profile`
 *   2. Add: `. "<generated script path>"`
 *   3. Save and reopen PowerShell
 */
export function generatePowerShellAutocompleteScript(cliDefinition: Cli): string {
  const subcommands = cliDefinition.subcommands ?? [];
  const meta = cliDefinition.meta ?? {};

  interface CommandData {
    options: string[];
    aliases: string[];
  }

  const mappedCommands: Record<string, CommandData> = {};

  // Map subcommands to their options and aliases
  for (const subcommand of subcommands) {
    const options: string[] = [];
    if (subcommand.options) {
      for (const key of Object.keys(subcommand.options)) {
        options.push(transformOptionToArgument(key));
      }
    }

    const aliases: string[] = subcommand.aliases ?? [];
    mappedCommands[subcommand.name] = { options, aliases };
  }

  // Prepare string representations for subcommands and CLI global options
  const subcommandsString = Object.keys(mappedCommands)
    .map(key => `'${key}'`)
    .join(", ");

  const cliOptions: string[] = [];
  if (cliDefinition.options) {
    for (const key of Object.keys(cliDefinition.options)) {
      cliOptions.push(transformOptionToArgument(key));
    }
  }

  const cliOptionsString = cliOptions.map(opt => `'${opt}'`).join(", ");

  // Build the switch-case mapping subcommands/aliases to their options
  let switchCase = "switch ($subcommand) {\n";
  for (const commandName in mappedCommands) {
    const data = mappedCommands[commandName];
    const optionsString = data.options.map(opt => `'${opt}'`).join(", ");

    // Primary subcommand
    switchCase += `        '${commandName}' { @(${optionsString}) }\n`;

    // Aliases
    for (const alias of data.aliases) {
      switchCase += `        '${alias}' { @(${optionsString}) }\n`;
    }
  }

  // Default case returns global CLI options
  switchCase += `        default { @(${cliOptionsString}) }\n    }`;

  // Optional comment block with description/example
  let commentBlock = "";
  if (meta.description || meta.example) {
    commentBlock = "<#\n";

    if (meta.description || meta.descriptionMarkdown) {
      commentBlock += `.DESCRIPTION\n${meta.description ?? meta.descriptionMarkdown}\n\n`;
    }

    if (meta.example) {
      commentBlock += `.EXAMPLE\n${meta.example}\n`;
    }

    commentBlock += "#>";
  }

  const cliName = cliDefinition.cliName;

  return `# Auto-generated by zod-args-parser

${commentBlock}
function ${cliName} {
    param(
        [Parameter(Position = 0, Mandatory = $false)]
        [string]$subcommand,
        [Parameter(Position = 1, ValueFromRemainingArguments = $true)]
        [string[]]$arguments
    )
    $scriptPath = (Get-Command '${cliName}.ps1').Source
    if ($scriptPath) {
        $argumentList = @($subcommand) + ($arguments | Where-Object { $_ -notin '--', '--%' }) | Where-Object { $_ -ne '' }
        & $scriptPath @argumentList
        return
    }
    Write-Error "Could not find '${cliName}.ps1' script"
}

Register-ArgumentCompleter -CommandName '${cliName}' -ParameterName 'subcommand' -ScriptBlock {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
    $subcommands = @(${subcommandsString}${subcommandsString && cliOptionsString ? ", " : ""}${cliOptionsString})
    $subcommands | Where-Object { $_ -like "$wordToComplete*" }
}

Register-ArgumentCompleter -CommandName '${cliName}' -ParameterName 'arguments' -ScriptBlock {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
    $subcommand = $commandAst.CommandElements[1].Value
    $arguments = ${switchCase}
    $arguments | Where-Object { $_ -like "$wordToComplete*" }
}`;
}
