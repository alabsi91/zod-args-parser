import { transformOptionToArg } from "../parser/parse/parser-helpers.js";

import type { Cli, Subcommand } from "../types.js";

/**
 * - Generates a PowerShell autocomplete script for your CLI.
 * - The script assumes that your CLI is available as a `.ps1` file in the environment variable. For example:
 *   `cliName.ps1`.
 * - This should return a path to your script: `(Get-Command <cliName>.ps1).Source`
 * - The generated script should be added to your `profile.ps1` file:
 *
 *   - Run: `notepad $profile`
 *   - Add the following line: `. "<generated script path>"`
 *   - Save and reopen powershell to take effect
 */
export function generatePowerShellAutocompleteScript(...params: [Cli, ...Subcommand[]]): string {
  const [cli, ...subcommands] = params;

  type MappedCommands = Record<string, { options: string[]; aliases: string[] }>;

  const mappedCommands = subcommands.reduce((acc: MappedCommands, subcommand) => {
    acc[subcommand.name] = {
      options: subcommand.options?.map(option => transformOptionToArg(option.name)) ?? [],
      aliases: subcommand.aliases ?? [],
    };
    return acc;
  }, {});

  const subcommandsStr = Object.keys(mappedCommands)
    .map(key => `'${key}'`)
    .join(", ");
  const cliOptionsStr = cli.options?.map(option => `'${transformOptionToArg(option.name)}'`).join(", ") || "";

  let switchCase = "switch ($subcommand) {\n";
  for (const [key, { options, aliases }] of Object.entries(mappedCommands)) {
    const optionsStr = options.map(option => `'${option}'`).join(", ");
    switchCase += `        '${key}' { @(${optionsStr}) }\n`;
    aliases.forEach(a => (switchCase += `        '${a}' { @(${optionsStr}) }\n`));
  }
  switchCase += `        default { @(${cliOptionsStr}) }\n    }`;

  let functionInfo = "";
  if (cli.description) {
    functionInfo = `<#\n.DESCRIPTION\n${cli.description}\n${cli.example ? `\n.EXAMPLE\n${cli.example}` : ""}\n#>`;
  }

  return `# Auto-generated by zod-args-parser

${functionInfo}
function ${cli.cliName} {
    param(
        [Parameter(Position = 0, Mandatory = $false)]
        [string]$subcommand,
        [Parameter(Position = 1, ValueFromRemainingArguments = $true)]
        [string[]]$arguments
    )
    $scriptPath = (Get-Command '${cli.cliName}.ps1').Source
    if ($scriptPath) {
        $argumentList = @($subcommand) + ($arguments | Where-Object { $_ -notin '--', '--%' }) | Where-Object { $_ -ne '' }
        & $scriptPath @argumentList
        return
    }
    Write-Error "Could not find '${cli.cliName}.ps1' script"
}

Register-ArgumentCompleter -CommandName '${cli.cliName}' -ParameterName 'subcommand' -ScriptBlock {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
    $subcommands = @(${subcommandsStr}${subcommandsStr && cliOptionsStr ? ", " : ""}${cliOptionsStr})
    $subcommands | Where-Object { $_ -like "$wordToComplete*" }
}

Register-ArgumentCompleter -CommandName '${cli.cliName}' -ParameterName 'arguments' -ScriptBlock {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
    $subcommand = $commandAst.CommandElements[1].Value
    $arguments = ${switchCase}
    $arguments | Where-Object { $_ -like "$wordToComplete*" }
}`;
}
