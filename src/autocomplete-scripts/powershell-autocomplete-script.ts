import { transformOptionToArgument } from "../parser/parse/parser-helpers.js";

import type { Cli, Subcommand } from "../types.js";

/**
 * - Generates a PowerShell autocomplete script for your CLI.
 * - The script assumes that your CLI is available as a `.ps1` file in the environment variable. For example:
 *   `cliName.ps1`.
 * - This should return a path to your script: `(Get-Command <cliName>.ps1).Source`
 * - The generated script should be added to your `profile.ps1` file:
 *
 *   - Run: `notepad $profile`
 *   - Add the following line: `. "<generated script path>"`
 *   - Save and reopen powershell to take effect
 */
export function generatePowerShellAutocompleteScript(...parameters: [Cli, ...Subcommand[]]): string {
  const [cli, ...subcommands] = parameters;

  type MappedCommands = Record<string, { options: string[]; aliases: string[] }>;

  const mappedCommands: MappedCommands = {};
  for (const subcommand of subcommands) {
    mappedCommands[subcommand.name] = {
      options: subcommand.options?.map(option => transformOptionToArgument(option.name)) ?? [],
      aliases: subcommand.aliases ?? [],
    };
  }

  const subcommandsString = Object.keys(mappedCommands)
    .map(key => `'${key}'`)
    .join(", ");
  const cliOptionsString = cli.options?.map(option => `'${transformOptionToArgument(option.name)}'`).join(", ") || "";

  let switchCase = "switch ($subcommand) {\n";
  for (const [key, { options, aliases }] of Object.entries(mappedCommands)) {
    const optionsString = options.map(option => `'${option}'`).join(", ");
    switchCase += `        '${key}' { @(${optionsString}) }\n`;
    for (const a of aliases) {
      switchCase += `        '${a}' { @(${optionsString}) }\n`;
    }
  }
  switchCase += `        default { @(${cliOptionsString}) }\n    }`;

  let functionInfo = "";
  if (cli.description) {
    functionInfo = `<#\n.DESCRIPTION\n${cli.description}\n${cli.example ? `\n.EXAMPLE\n${cli.example}` : ""}\n#>`;
  }

  return `# Auto-generated by zod-args-parser

${functionInfo}
function ${cli.cliName} {
    param(
        [Parameter(Position = 0, Mandatory = $false)]
        [string]$subcommand,
        [Parameter(Position = 1, ValueFromRemainingArguments = $true)]
        [string[]]$arguments
    )
    $scriptPath = (Get-Command '${cli.cliName}.ps1').Source
    if ($scriptPath) {
        $argumentList = @($subcommand) + ($arguments | Where-Object { $_ -notin '--', '--%' }) | Where-Object { $_ -ne '' }
        & $scriptPath @argumentList
        return
    }
    Write-Error "Could not find '${cli.cliName}.ps1' script"
}

Register-ArgumentCompleter -CommandName '${cli.cliName}' -ParameterName 'subcommand' -ScriptBlock {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
    $subcommands = @(${subcommandsString}${subcommandsString && cliOptionsString ? ", " : ""}${cliOptionsString})
    $subcommands | Where-Object { $_ -like "$wordToComplete*" }
}

Register-ArgumentCompleter -CommandName '${cli.cliName}' -ParameterName 'arguments' -ScriptBlock {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
    $subcommand = $commandAst.CommandElements[1].Value
    $arguments = ${switchCase}
    $arguments | Where-Object { $_ -like "$wordToComplete*" }
}`;
}
