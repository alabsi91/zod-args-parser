import { transformOptionToArgument } from "../parse/parser-utilities.ts";

import type { Cli } from "../types/definitions-types.ts";

/**
 * - Generate bash autocomplete script for your CLI
 * - The generated script should be added to your `.bash_profile` or `.bashrc` file:
 *
 *   - Run: `nano $HOME/.bash_profile` or `nano $HOME/.bashrc`
 *   - Add the following line: `source <generated script path>`
 *   - Save and reopen bash to take effect
 */
export function generateBashAutocompleteScript(cliDefinition: Cli): string {
  const subcommands = cliDefinition.subcommands ?? [];
  type MappedCommands = Record<string, { options: string[]; aliases: string[] }>;

  // Map subcommands to options + aliases
  const mappedCommands: MappedCommands = {};
  for (const subcommand of subcommands) {
    mappedCommands[subcommand.name] = {
      options: subcommand.options ? Object.keys(subcommand.options).map(key => transformOptionToArgument(key)) : [],
      aliases: subcommand.aliases ?? [],
    };
  }

  // Generate switch-case block for subcommands + aliases
  let switchCase = "";
  for (const [name, { options, aliases }] of Object.entries(mappedCommands)) {
    const caseNames = [name, ...aliases];
    switchCase += `    ${caseNames.join("|")})\n`;
    switchCase += `      opts="${options.join(" ")}"\n`;
    switchCase += "      ;;\n";
  }

  // Include global CLI options in a default case
  const globalOptions = cliDefinition.options
    ? Object.keys(cliDefinition.options).map(key => transformOptionToArgument(key))
    : [];

  if (globalOptions.length > 0) {
    switchCase += `    *)\n`;
    switchCase += `      opts="${globalOptions.join(" ")}"\n`;
    switchCase += "      ;;\n";
  }

  return `# Auto-generated by zod-args-parser

_${cliDefinition.cliName}_autocomplete() {
  local cur prev commands opts subcommand used_opts filtered_opts

  cur="\${COMP_WORDS[COMP_CWORD]}"
  prev="\${COMP_WORDS[COMP_CWORD-1]}"
  subcommand="\${COMP_WORDS[1]}"

  commands="${Object.keys(mappedCommands).join(" ")}"

  case "$subcommand" in
${switchCase}  esac

  used_opts=""
  if [[ " \${commands[@]} " =~ " $subcommand " ]]; then
    for word in "\${COMP_WORDS[@]:2}"; do
      if [[ "$word" =~ ^- ]]; then
        used_opts+=" $word"
      fi
    done
  fi

  if [[ -n "$opts" ]]; then
    filtered_opts=""
    for opt in $opts; do
      if [[ ! " $used_opts " =~ " $opt " ]]; then
        filtered_opts+="$opt "
      fi
    done
    COMPREPLY=( $(compgen -W "$filtered_opts" -- "$cur") )
    return
  fi

  if [[ "\${COMP_CWORD}" -eq 1 ]]; then
    COMPREPLY=( $(compgen -W "$commands" -- "$cur") )
  fi
}

complete -F _${cliDefinition.cliName}_autocomplete ${cliDefinition.cliName}
`;
}
