import { getCliMetadata } from "../metadata/get-cli-metadata.ts";

import type { ArgumentMetadata, OptionMetadata, SubcommandMetadata } from "../metadata/metadata-types.ts";
import type { Cli } from "../schemas/schema-types.ts";

export function generateMarkdown(cli: Cli): string {
  const metadata = getCliMetadata(cli);

  let md = "<!-- Auto-generated by zod-args-parser -->\n\n";

  // Title
  md += `# ${metadata.name}\n\n`;

  // Description
  if (metadata.description && !metadata.descriptionMarkdown) {
    md += `${metadata.description}\n`;
  }

  // Description Markdown
  if (metadata.descriptionMarkdown) {
    md += `${metadata.descriptionMarkdown}\n`;
  }

  // Examples
  if (metadata.example) {
    md += renderExamples(metadata.example);
  }

  // Options
  if (metadata.options.length > 0) {
    md += "\n## Options:\n\n";
    md += renderOptions(metadata.options, 3);
  }

  // Arguments
  if (metadata.arguments.length > 0) {
    md += "\n## Arguments:\n\n";
    md += renderArguments(metadata.arguments, 3);
  }

  // Subcommands
  if (metadata.subcommands.length > 0) {
    md += "\n## Subcommands:\n\n";
    md += renderSubcommands(metadata.subcommands);
  }

  md = stripAnsi(md);
  md = escapeHtmlTags(md);

  return md;
}

function renderExamples(examples: string) {
  let outString = "\n**Example:**\n";

  const lang = "bash";

  outString += "\n";
  outString += "```" + lang + "\n";
  outString += examples;
  outString += "\n```\n";

  return outString;
}

function renderOptions(optionsMetadata: OptionMetadata[] = [], h: number) {
  let outString = "";

  for (let index = 0; index < optionsMetadata.length; index++) {
    const metadata = optionsMetadata[index];
    if (metadata.hidden) continue;

    const aliases = [metadata.nameAsArg].concat(metadata.aliasesAsArgs).join(", ");

    const placeholder = metadata.placeholder && ` ${metadata.placeholder}`;

    outString += `${"#".repeat(h)} \`${aliases + placeholder}\``;

    if (metadata.optional) {
      outString += " _optional_";
    }

    outString += "\n\n";

    if (metadata.description && !metadata.descriptionMarkdown) {
      outString += `${metadata.description.replace(/(\n+)/g, "  $1 ")}\n`;
    }

    if (metadata.descriptionMarkdown) {
      outString += `${metadata.descriptionMarkdown}\n`;
    }

    if (metadata.defaultValue !== undefined) {
      outString += `\n**default:** \`${metadata.defaultValueAsString}\`\n`;
    }

    if (metadata.example) {
      outString += renderExamples(metadata.example);
    }

    if (index < optionsMetadata.length - 1) {
      outString += "\n";
    }
  }

  return outString;
}

function renderArguments(argumentsMetadata: ArgumentMetadata[] = [], h: number) {
  let outString = "";

  for (let index = 0; index < argumentsMetadata.length; index++) {
    const metadata = argumentsMetadata[index];
    if (metadata.hidden) continue;

    outString += `${"#".repeat(h)} \`${metadata.name}\``;

    if (metadata.optional) {
      outString += " _optional_";
    }

    outString += "\n\n";

    if (metadata.description && !metadata.descriptionMarkdown) {
      outString += `${metadata.description.replace(/(\n+)/g, "  $1 ")}\n`;
    }

    if (metadata.descriptionMarkdown) {
      outString += `${metadata.descriptionMarkdown}\n`;
    }

    if (metadata.defaultValue !== undefined) {
      outString += `\n**default:** \`${metadata.defaultValueAsString}\`\n`;
    }

    if (metadata.example) {
      outString += renderExamples(metadata.example);
    }

    if (index < argumentsMetadata.length - 1) {
      outString += "\n";
    }
  }

  return outString;
}

function renderSubcommands(subcommandsMetadata: SubcommandMetadata[]) {
  let outString = "";

  for (let index = 0; index < subcommandsMetadata.length; index++) {
    const metadata = subcommandsMetadata[index];
    if (metadata.hidden) continue;

    const aliases = [metadata.name].concat(metadata.aliases).join(", ");

    const placeholder = metadata.placeholder && ` ${metadata.placeholder}`;

    outString += `### ${aliases + placeholder}\n\n`;

    if (metadata.description && !metadata.descriptionMarkdown) {
      outString += `${metadata.description}\n`;
    }

    if (metadata.descriptionMarkdown) {
      outString += `${metadata.descriptionMarkdown}\n`;
    }

    if (metadata.example) {
      outString += renderExamples(metadata.example);
    }

    if (metadata.options.length > 0) {
      outString += "\n#### Options:\n\n";
      outString += renderOptions(metadata.options, 4);
    }

    if (metadata.arguments.length > 0) {
      outString += "\n#### Arguments:\n\n";
      outString += renderArguments(metadata.arguments, 4);
    }

    if (index < subcommandsMetadata.length - 1) {
      outString += "\n---\n\n";
    }
  }

  return outString;
}

/**
 * Escape HTML characters inside HTML tags in a Markdown string, but leave code blocks, inline code, and HTML comments
 * unchanged.
 */
export function escapeHtmlTags(markdown: string): string {
  const escapeMap: Record<string, string> = { "&": "&amp;", "<": "&lt;", ">": "&gt;" };

  // Captures:
  // 1) fenced code blocks or inline code
  // 2) HTML comments <!-- ... -->
  // 3) other HTML tags like <b>, <div attr="x">, etc.
  const re = /(```[\s\S]*?```|`[^`]*`)|(<!--[\s\S]*?-->)|(<[^>]+>)/g;

  return markdown.replace(re, (fullMatch: string, code?: string, comment?: string, tag?: string) => {
    if (code) return code;
    if (comment) return comment;
    if (!tag) return fullMatch;

    return tag.replace(/[&<>]/g, ch => escapeMap[ch]);
  });
}

/** Credits: https://github.com/chalk/ansi-regex */
function ansiRegex({ onlyFirst = false } = {}) {
  // Valid string terminator sequences are BEL, ESC\, and 0x9c
  const ST = String.raw`(?:\u0007|\u001B\u005C|\u009C)`;

  // OSC sequences only: ESC ] ... ST (non-greedy until the first ST)
  const osc = `(?:\\u001B\\][\\s\\S]*?${ST})`;

  // CSI and related: ESC/C1, optional intermediates, optional params (supports ; and :) then final byte
  const csi = String.raw`[\u001B\u009B][[\]()#;?]*(?:\d{1,4}(?:[;:]\d{0,4})*)?[\dA-PR-TZcf-nq-uy=><~]`;

  const pattern = `${osc}|${csi}`;

  return new RegExp(pattern, onlyFirst ? undefined : "g");
}

const regex = ansiRegex();

function stripAnsi(string: string): string {
  return string.replace(regex, "");
}
