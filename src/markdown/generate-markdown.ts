import { getCliMetadata } from "../metadata/get-cli-metadata.js";

import type { ArgumentMetadata, OptionMetadata, SubcommandMetadata } from "../metadata/metadata-types.js";
import type { Cli, Subcommand } from "../types.js";

export function generateMarkdown(...parameters: [Cli, ...Subcommand[]]): string {
  const metadata = getCliMetadata(parameters);

  let md = "<!-- Auto-generated by zod-args-parser -->\n\n";

  // Title
  md += `# ${metadata.name}\n\n`;

  // Description
  if (metadata.description) {
    md += `${metadata.description}\n`;
  }

  // Examples
  if (metadata.example) {
    md += renderExamples(metadata.example);
  }

  // Options
  if (metadata.options.length > 0) {
    md += "\n## Options:\n\n";
    md += renderOptions(metadata.options, 3);
  }

  // Arguments
  if (metadata.arguments.length > 0) {
    md += "\n## Arguments:\n\n";
    md += renderArguments(metadata.arguments, 3);
  }

  // Subcommands
  if (metadata.subcommands.length > 0) {
    md += "\n## Subcommands:\n\n";
    md += renderSubcommands(metadata.subcommands);
  }

  md = stripAnsi(md);
  md = escapeHtmlTags(md);

  return md;
}

function renderExamples(examples: string, list = false) {
  let outString = "";

  const lang = "bash";

  const listIndent = " ".repeat(list ? 2 : 0);

  outString += "\n" + (list ? "- " : "");

  outString += "```" + lang + "\n";
  outString += listIndent + examples.replace(/\n/g, "\n" + listIndent);
  outString += "\n" + listIndent + "```\n";

  return outString;
}

function renderOptions(optionsMetadata: OptionMetadata[] = [], h: number) {
  let outString = "";

  for (let index = 0; index < optionsMetadata.length; index++) {
    const metadata = optionsMetadata[index];

    const aliases = [metadata.nameAsArg].concat(metadata.aliasesAsArgs).join(", ");

    const placeholder = metadata.placeholder && ` ${metadata.placeholder}`;

    outString += `${"#".repeat(h)} \`${aliases + placeholder}\``;

    if (metadata.optional) {
      outString += " **[optional]**";
    }

    outString += "\n\n";

    if (metadata.description) {
      outString += `- ${metadata.description.replace(/(\n+)/g, "  $1  ")}\n`;
    }

    if (metadata.defaultValue !== undefined) {
      outString += `- **default:** \`${metadata.defaultValueAsString}\`\n`;
    }

    if (metadata.example) {
      outString += renderExamples(metadata.example, true);
    }

    if (index < optionsMetadata.length - 1) {
      outString += "\n";
    }
  }

  return outString;
}

function renderArguments(argumentsMetadata: ArgumentMetadata[] = [], h: number) {
  let outString = "";

  for (let index = 0; index < argumentsMetadata.length; index++) {
    const metadata = argumentsMetadata[index];

    outString += `${"#".repeat(h)} \`${metadata.name}\``;

    if (metadata.optional) {
      outString += " **[optional]**";
    }

    outString += "\n\n";

    if (metadata.description) {
      outString += `- ${metadata.description.replace(/(\n+)/g, "  $1  ")}\n`;
    }

    if (metadata.defaultValue !== undefined) {
      outString += `- **default:** \`${metadata.defaultValueAsString}\`\n`;
    }

    if (metadata.example) {
      outString += renderExamples(metadata.example);
    }

    if (index < argumentsMetadata.length - 1) {
      outString += "\n";
    }
  }

  return outString;
}

function renderSubcommands(subcommandsMetadata: SubcommandMetadata[]) {
  let outString = "";

  for (let index = 0; index < subcommandsMetadata.length; index++) {
    const metadata = subcommandsMetadata[index];

    const aliases = [metadata.name].concat(metadata.aliases).join(", ");

    const placeholder = metadata.placeholder && ` ${metadata.placeholder}`;

    outString += `### ${aliases + placeholder}\n\n`;

    if (metadata.description) {
      outString += `${metadata.description}\n`;
    }

    if (metadata.example) {
      outString += renderExamples(metadata.example);
    }

    if (metadata.options.length > 0) {
      outString += "\n#### Options:\n\n";
      outString += renderOptions(metadata.options, 4);
    }

    if (metadata.arguments.length > 0) {
      outString += "\n#### Arguments:\n\n";
      outString += renderArguments(metadata.arguments, 4);
    }

    if (index < subcommandsMetadata.length - 1) {
      outString += "\n---\n\n";
    }
  }

  return outString;
}

function escapeHtmlTags(markdown: string) {
  return markdown.replace(/(```[\s\S]*?```|`[^`]*`)|(<[^>]+>)/g, (_: string, code: string, html: string) => {
    if (code) {
      return code;
    }

    return html.replace(/[&<>]/g, match => {
      return { "&": "&amp;", "<": "&lt;", ">": "&gt;" }[match as "&" | "<" | ">"];
    });
  });
}

/** Credits: https://github.com/chalk/ansi-regex */
function ansiRegex({ onlyFirst = false } = {}) {
  // Valid string terminator sequences are BEL, ESC\, and 0x9c
  const ST = String.raw`(?:\u0007|\u001B\u005C|\u009C)`;

  // OSC sequences only: ESC ] ... ST (non-greedy until the first ST)
  const osc = `(?:\\u001B\\][\\s\\S]*?${ST})`;

  // CSI and related: ESC/C1, optional intermediates, optional params (supports ; and :) then final byte
  const csi = String.raw`[\u001B\u009B][[\]()#;?]*(?:\d{1,4}(?:[;:]\d{0,4})*)?[\dA-PR-TZcf-nq-uy=><~]`;

  const pattern = `${osc}|${csi}`;

  return new RegExp(pattern, onlyFirst ? undefined : "g");
}

const regex = ansiRegex();

function stripAnsi(string: string): string {
  return string.replace(regex, "");
}
