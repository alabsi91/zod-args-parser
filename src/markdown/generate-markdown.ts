import { getCliMetadata } from "../metadata/cli-metadata.ts";
import { escapeHtmlTags, stripAnsi } from "../utilities.ts";

import type { Cli } from "../types/definitions-types.ts";
import type { ArgumentMetadata, OptionMetadata, SubcommandMetadata } from "../types/metadata-types.ts";

export function generateMarkdown(cliDefinition: Cli): string {
  const metadata = getCliMetadata(cliDefinition);

  let md = "<!-- Auto-generated by typed-arg-parser -->\n\n";

  // Title
  md += `# ${metadata.name}\n\n`;

  // Description
  if (metadata.description && !metadata.descriptionMarkdown) {
    md += `${forceLineBreak(metadata.description)}\n`;
  }

  // Description Markdown
  if (metadata.descriptionMarkdown) {
    md += `${forceLineBreak(metadata.descriptionMarkdown)}\n`;
  }

  // Examples
  if (metadata.example) {
    md += renderExamples(metadata.example);
  }

  // Options
  if (metadata.options.length > 0) {
    md += "\n## Options:\n\n";
    md += renderOptions(metadata.options, 3);
  }

  // Arguments
  if (metadata.arguments.length > 0) {
    md += "\n## Arguments:\n\n";
    md += renderArguments(metadata.arguments, 3);
  }

  // Subcommands
  if (metadata.subcommands.length > 0) {
    md += "\n## Subcommands:\n\n";
    md += renderSubcommands(metadata.subcommands);
  }

  md = stripAnsi(md);
  md = escapeHtmlTags(md);

  return md;
}

function renderExamples(examples: string) {
  let outString = "\n**Example:**\n";

  const lang = "bash";

  outString += "\n";
  outString += "```" + lang + "\n";
  outString += examples;
  outString += "\n```\n";

  return outString;
}

function renderOptions(optionsMetadata: OptionMetadata[] = [], h: number) {
  let outString = "";

  for (let index = 0; index < optionsMetadata.length; index++) {
    const metadata = optionsMetadata[index];
    if (metadata.hidden) continue;

    const aliases = [metadata.nameAsArg].concat(metadata.aliasesAsArgs).join(", ");

    const placeholder = metadata.placeholder && ` ${metadata.placeholder}`;

    outString += `${"#".repeat(h)} \`${aliases + placeholder}\``;

    if (metadata.optional) {
      outString += " _optional_";
    }

    outString += "\n\n";

    if (metadata.description && !metadata.descriptionMarkdown) {
      outString += `${forceLineBreak(metadata.description)}\n`;
    }

    if (metadata.descriptionMarkdown) {
      outString += `${forceLineBreak(metadata.descriptionMarkdown)}\n`;
    }

    if (metadata.defaultValue !== undefined) {
      outString += `\n**default:** \`${metadata.defaultValueAsString}\`\n`;
    }

    if (metadata.example) {
      outString += renderExamples(metadata.example);
    }

    if (index < optionsMetadata.length - 1) {
      outString += "\n";
    }
  }

  return outString;
}

function renderArguments(argumentsMetadata: ArgumentMetadata[] = [], h: number) {
  let outString = "";

  for (let index = 0; index < argumentsMetadata.length; index++) {
    const metadata = argumentsMetadata[index];
    if (metadata.hidden) continue;

    outString += `${"#".repeat(h)} \`${metadata.name}\``;

    if (metadata.optional) {
      outString += " _optional_";
    }

    outString += "\n\n";

    if (metadata.description && !metadata.descriptionMarkdown) {
      outString += `${forceLineBreak(metadata.description)}\n`;
    }

    if (metadata.descriptionMarkdown) {
      outString += `${forceLineBreak(metadata.descriptionMarkdown)}\n`;
    }

    if (metadata.defaultValue !== undefined) {
      outString += `\n**default:** \`${metadata.defaultValueAsString}\`\n`;
    }

    if (metadata.example) {
      outString += renderExamples(metadata.example);
    }

    if (index < argumentsMetadata.length - 1) {
      outString += "\n";
    }
  }

  return outString;
}

function renderSubcommands(subcommandsMetadata: SubcommandMetadata[]) {
  let outString = "";

  for (let index = 0; index < subcommandsMetadata.length; index++) {
    const metadata = subcommandsMetadata[index];
    if (metadata.hidden) continue;

    const aliases = [metadata.name].concat(metadata.aliases).join(", ");

    const placeholder = metadata.placeholder && ` ${metadata.placeholder}`;

    outString += `### ${aliases + placeholder}\n\n`;

    if (metadata.description && !metadata.descriptionMarkdown) {
      outString += `${forceLineBreak(metadata.description)}\n`;
    }

    if (metadata.descriptionMarkdown) {
      outString += `${forceLineBreak(metadata.descriptionMarkdown)}\n`;
    }

    if (metadata.example) {
      outString += renderExamples(metadata.example);
    }

    if (metadata.options.length > 0) {
      outString += "\n#### Options:\n\n";
      outString += renderOptions(metadata.options, 4);
    }

    if (metadata.arguments.length > 0) {
      outString += "\n#### Arguments:\n\n";
      outString += renderArguments(metadata.arguments, 4);
    }

    if (index < subcommandsMetadata.length - 1) {
      outString += "\n---\n\n";
    }
  }

  return outString;
}

/** Inserts two trailing spaces before newline. In Markdown, a newline that ends with two spaces forces a line break. */
function forceLineBreak(string: string): string {
  return string.replace(/(\n+)/g, "  $1");
}
